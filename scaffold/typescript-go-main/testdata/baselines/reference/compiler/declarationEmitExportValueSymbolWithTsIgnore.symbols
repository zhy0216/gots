//// [tests/cases/compiler/declarationEmitExportValueSymbolWithTsIgnore.ts] ////

=== node_modules/lib/index.d.ts ===
export declare const MySymbol: unique symbol;
>MySymbol : Symbol(MySymbol, Decl(index.d.ts, 0, 20))

export declare function createService<T>(): {
>createService : Symbol(createService, Decl(index.d.ts, 0, 45))
>T : Symbol(T, Decl(index.d.ts, 1, 38))

    new (): {
        [MySymbol](): T | undefined;
>[MySymbol] : Symbol([MySymbol], Decl(index.d.ts, 2, 13))
>MySymbol : Symbol(MySymbol, Decl(index.d.ts, 0, 20))
>T : Symbol(T, Decl(index.d.ts, 1, 38))

    };
};

=== client.ts ===
// @ts-ignore Import needed for type visibility but appears unused
import { MySymbol } from "lib";
>MySymbol : Symbol(MySymbol, Decl(client.ts, 1, 8))

import { createService } from "lib";
>createService : Symbol(createService, Decl(client.ts, 2, 8))

// The extends clause references the factory result which uses MySymbol
// This should trigger symbol accessibility check for MySymbol
export class Client extends createService<string>() {
>Client : Symbol(Client, Decl(client.ts, 2, 36))
>createService : Symbol(createService, Decl(client.ts, 2, 8))

    doSomething(): string {
>doSomething : Symbol(Client.doSomething, Decl(client.ts, 6, 53))

        return "hello";
    }
}

