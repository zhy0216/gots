//// [tests/cases/compiler/declarationEmitExportValueSymbolWithTsIgnore.ts] ////

=== node_modules/lib/index.d.ts ===
export declare const MySymbol: unique symbol;
>MySymbol : unique symbol

export declare function createService<T>(): {
>createService : <T>() => new () => { [MySymbol](): T | undefined; }

    new (): {
        [MySymbol](): T | undefined;
>[MySymbol] : () => T | undefined
>MySymbol : unique symbol

    };
};

=== client.ts ===
// @ts-ignore Import needed for type visibility but appears unused
import { MySymbol } from "lib";
>MySymbol : unique symbol

import { createService } from "lib";
>createService : <T>() => new () => { [MySymbol](): T | undefined; }

// The extends clause references the factory result which uses MySymbol
// This should trigger symbol accessibility check for MySymbol
export class Client extends createService<string>() {
>Client : Client
>createService<string>() : { [MySymbol](): string | undefined; }
>createService : <T>() => new () => { [MySymbol](): T | undefined; }

    doSomething(): string {
>doSomething : () => string

        return "hello";
>"hello" : "hello"
    }
}

