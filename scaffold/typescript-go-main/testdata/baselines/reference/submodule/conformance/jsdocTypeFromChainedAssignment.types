//// [tests/cases/conformance/jsdoc/jsdocTypeFromChainedAssignment.ts] ////

=== a.js ===
function A () {
>A : { (): void; s: (m: number) => any; t: (m: number) => any; }

    this.x = 1
>this.x = 1 : 1
>this.x : any
>this : any
>x : any
>1 : 1

    /** @type {1} */
    this.first = this.second = 1
>this.first = this.second = 1 : 1
>this.first : any
>this : any
>first : any
>this.second = 1 : 1
>this.second : any
>this : any
>second : any
>1 : 1
}
/** @param {number} n */
A.prototype.y = A.prototype.z = function f(n) {
>A.prototype.y = A.prototype.z = function f(n) {    return n + this.x} : (n: number) => any
>A.prototype.y : any
>A.prototype : any
>A : { (): void; s: (m: number) => any; t: (m: number) => any; }
>prototype : any
>y : any
>A.prototype.z = function f(n) {    return n + this.x} : (n: number) => any
>A.prototype.z : any
>A.prototype : any
>A : { (): void; s: (m: number) => any; t: (m: number) => any; }
>prototype : any
>z : any
>function f(n) {    return n + this.x} : (n: number) => any
>f : (n: number) => any
>n : number

    return n + this.x
>n + this.x : any
>n : number
>this.x : any
>this : any
>x : any
}
/** @param {number} m */
A.s = A.t = function g(m) {
>A.s = A.t = function g(m) {    return m + this.x} : (m: number) => any
>A.s : (m: number) => any
>A : { (): void; s: (m: number) => any; t: (m: number) => any; }
>s : (m: number) => any
>A.t = function g(m) {    return m + this.x} : (m: number) => any
>A.t : (m: number) => any
>A : { (): void; s: (m: number) => any; t: (m: number) => any; }
>t : (m: number) => any
>function g(m) {    return m + this.x} : (m: number) => any
>g : (m: number) => any
>m : number

    return m + this.x
>m + this.x : any
>m : number
>this.x : any
>this : any
>x : any
}
var a = new A()
>a : any
>new A() : any
>A : { (): void; s: (m: number) => any; t: (m: number) => any; }

a.y('no') // error
>a.y('no') : any
>a.y : any
>a : any
>y : any
>'no' : "no"

a.z('not really') // error
>a.z('not really') : any
>a.z : any
>a : any
>z : any
>'not really' : "not really"

A.s('still no') // error
>A.s('still no') : any
>A.s : (m: number) => any
>A : { (): void; s: (m: number) => any; t: (m: number) => any; }
>s : (m: number) => any
>'still no' : "still no"

A.t('not here either') // error
>A.t('not here either') : any
>A.t : (m: number) => any
>A : { (): void; s: (m: number) => any; t: (m: number) => any; }
>t : (m: number) => any
>'not here either' : "not here either"

a.first = 10 // error: '10' isn't assignable to '1'
>a.first = 10 : 10
>a.first : any
>a : any
>first : any
>10 : 10

